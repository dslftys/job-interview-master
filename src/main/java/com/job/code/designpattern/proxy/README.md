# 代理模式

## 静态代理

真实类Car 实现接口Moveable，功能开车。
代理类 ，功能开车+计时。

方法一：继承（不推荐）

代理类CarExtend 继承真实类Car，并对父类Car进行增强

方法二：聚合（实现接口）

代理类CarImplement实现了接口Moveable，其中含有Car对象，在方法的实现中，调用Car的原始方法并增强。

###比较

继承方式，要为不同的代理内容创建不同的代理类（功能的叠加）。例如若先执行增强功能1，再执行增强功能2，需要创建代理类A；若先执行增强功能2，再执行增强功能1，需要创建代理类B……

聚合方式，为不同的功能创建不同的代理类，在使用时只需要迭代实例化即可。

继承方式是针对代理类来编程，一个代理类代表一个完整的代理后对象。聚合方式是针对代理方法来编程，一个代理类代表一个完整的代理功能，需要传入真实对象后才可以用。

## 动态代理

把手动编写，变成动态产生。

方法一：JDK动态代理（反射）

在运行时生成代理后的Class，必须被代理类要实现接口，必须实现Handler（具体业务在Handler）

1、创建并实现InvocationHandler类，并实现invoke方法（完成代理增强功能）
2、创建被代理类
3、利用Proxy.newProxyInstance方法创建一个代理类
4、调用代理类的方法

方法二：CGLIB动态代理（继承）

###对比

JDK动态代理：只能代理实现了接口的类。
CGLIB代理：针对类实现代理，生成一个子类。（final的类不可以）

##总结

静态代理，对固定真实类做代理。如:CarProxy -> Car ; TrainProxy ->Train ......
假设有100种交通工具，则需要100个代理类，每个类中代理方法一样，只是聚合的对象类型不同，甚至执行的方法都一样。

动态代理，对任意真实类做代理。如：Proxy -> Car、Train.......
一个代理类，动态产生不同的真实类。